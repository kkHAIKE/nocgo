package main

import (
	"fmt"
	"io"
	"path/filepath"
	"strings"
)

const asmHead = `// +build !noasm !appengine
// Code generated by nocgo, DO NOT EDIT.

#include "go_asm.h"
#include "funcdata.h"
#include "textflag.h"

TEXT ·__native_entry__(SB), NOSPLIT, $0
	NO_LOCAL_POINTERS
`

func writeGoASM(w io.Writer, p *Prog, funcs Functions, arch Arch) (err error) {
	if _, err = fmt.Fprint(w, asmHead); err != nil {
		return
	}
	if err = arch.WriteHead(w); err != nil {
		return
	}
	if err = arch.WriteProg(w, p); err != nil {
		return
	}
	for _, v := range funcs {
		if _, err = fmt.Fprintf(w, "\nTEXT ·%s(SB), NOSPLIT | NOFRAME, $0 - %d\n\tNO_LOCAL_POINTERS\n", v.Name, v.ArgsSize()); err != nil {
			return
		}

		bb := p.GetBB(v.Name[1:])
		spsize := -p.SPDetect(bb, make(map[*BasicBlock]bool))
		if err = arch.WriteFunc(w, v, spsize, bb.EA()); err != nil {
			return
		}
	}
	return
}

var KnownOS = map[string]bool{
	"aix":       true,
	"android":   true,
	"darwin":    true,
	"dragonfly": true,
	"freebsd":   true,
	"hurd":      true,
	"illumos":   true,
	"ios":       true,
	"js":        true,
	"linux":     true,
	"nacl":      true, // legacy; don't remove
	"netbsd":    true,
	"openbsd":   true,
	"plan9":     true,
	"solaris":   true,
	"windows":   true,
	"zos":       true,
}

var KnownArch = map[string]bool{
	"386":         true,
	"amd64":       true,
	"amd64p32":    true, // legacy; don't remove
	"arm":         true,
	"armbe":       true,
	"arm64":       true,
	"arm64be":     true,
	"ppc64":       true,
	"ppc64le":     true,
	"mips":        true,
	"mipsle":      true,
	"mips64":      true,
	"mips64le":    true,
	"mips64p32":   true,
	"mips64p32le": true,
	"ppc":         true,
	"riscv":       true,
	"riscv64":     true,
	"s390":        true,
	"s390x":       true,
	"sparc":       true,
	"sparc64":     true,
	"wasm":        true,
}

func subrFileName(fpath string) string {
	fdir, fname := filepath.Split(fpath)
	arr := strings.Split(fname[:len(fname)-2], "_")
	n := len(arr)
	idx := n

	switch {
	case n > 2 && KnownOS[arr[n-2]] && KnownArch[arr[n-1]]:
		idx = n - 2
	case n > 1 && (KnownOS[arr[n-1]] || KnownArch[arr[n-1]]):
		idx = n - 1
	}
	arr = append(arr[:idx], append([]string{"subr"}, arr[idx:]...)...)
	return filepath.Join(fdir, strings.Join(arr, "_")+".go")
}

const subrHead = `// +build !noasm !appengine
// Code generated by nocgo, DO NOT EDIT.

package %s

//go:nosplit
//go:noescape
//goland:noinspection ALL
func __native_entry__() uintptr
`

func writeSubr(w io.Writer, p *Prog, funcs Functions, pkg string, arch Arch) (err error) {
	if _, err = fmt.Fprintf(w, subrHead, pkg); err != nil {
		return
	}

	entry, err := arch.SubrEntry(w)
	if err != nil {
		return
	}
	if entry == "" {
		entry = "__native_entry__"
	}

	rangeFuncs := func(decl []byte, cb func(f *Function) error) (err error) {
		if _, err = w.Write(decl); err != nil {
			return
		}
		for _, v := range funcs {
			if err = cb(v); err != nil {
				return
			}
		}
		if _, err = w.Write([]byte(")\n")); err != nil {
			return
		}
		return
	}

	if err = rangeFuncs([]byte("\nvar (\n"), func(f *Function) error {
		bb := p.GetBB(f.Name[1:])
		if _, err := fmt.Fprintf(w, "\t_subr%s = %s() + %d\n", f.Name, entry, bb.EA()); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return
	}

	if err = rangeFuncs([]byte("\nconst (\n"), func(f *Function) error {
		bb := p.GetBB(f.Name[1:])
		spsize := -p.SPDetect(bb, make(map[*BasicBlock]bool))
		if _, err := fmt.Fprintf(w, "\t_stack%s = %d\n", f.Name, spsize); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return
	}

	if err = rangeFuncs([]byte("\nvar (\n"), func(f *Function) error {
		if _, err := fmt.Fprintf(w, "\t_ = _subr%s\n", f.Name); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return
	}

	if err = rangeFuncs([]byte("\nconst (\n"), func(f *Function) error {
		if _, err := fmt.Fprintf(w, "\t_ = _stack%s\n", f.Name); err != nil {
			return err
		}
		return nil
	}); err != nil {
		return
	}
	return
}
